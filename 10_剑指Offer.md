<!-- TOC -->

- [面试题4 二维数组中的查找](#面试题4-二维数组中的查找)
- [面试题5 替换空格](#面试题5-替换空格)
- [面试题6 从尾到头打印链表](#面试题6-从尾到头打印链表)
- [面试题7 重建二叉树](#面试题7-重建二叉树)
- [面试题9 用两个栈实现队列](#面试题9-用两个栈实现队列)
- [面试题11 旋转数组的最小数字](#面试题11-旋转数组的最小数字)
- [面试题10 斐波那契数列](#面试题10-斐波那契数列)
- [跳台阶](#跳台阶)
- [变态跳台阶](#变态跳台阶)
- [矩形覆盖](#矩形覆盖)
- [面试题15 二进制中1的个数](#面试题15-二进制中1的个数)
- [面试题16 数值的整数次方](#面试题16-数值的整数次方)
- [面试题21 调整数组顺序使奇数位于偶数前面](#面试题21-调整数组顺序使奇数位于偶数前面)
- [面试题22 链表中倒数第k个结点](#面试题22-链表中倒数第k个结点)
- [面试题24 反转链表](#面试题24-反转链表)
- [面试题25 合并两个排序的链表](#面试题25-合并两个排序的链表)
- [面试题26 树的子结构](#面试题26-树的子结构)
- [面试题27 二叉树的镜像](#面试题27-二叉树的镜像)
- [面试题29 顺时针打印矩阵](#面试题29-顺时针打印矩阵)
- [面试题30 包含min函数的栈](#面试题30-包含min函数的栈)
- [面试题31 栈的压入、弹出序列](#面试题31-栈的压入弹出序列)
- [面试题32 从上往下打印二叉树](#面试题32-从上往下打印二叉树)
- [面试题33 二叉搜索树的后序遍历序列](#面试题33-二叉搜索树的后序遍历序列)
- [面试题35 复杂链表的复制](#面试题35-复杂链表的复制)
- [面试题36 二叉搜索树与双向链表](#面试题36-二叉搜索树与双向链表)
- [面试题38 字符串的排列](#面试题38-字符串的排列)
- [面试题39 数组中出现次数超过一半的数字](#面试题39-数组中出现次数超过一半的数字)
- [面试题41 最小的K个数](#面试题41-最小的k个数)
- [面试题42 连续子数组的最大和](#面试题42-连续子数组的最大和)
- [面试题43 整数中1出现的次数（从1到n整数中1出现的次数）](#面试题43-整数中1出现的次数从1到n整数中1出现的次数)
- [面试题45 把数组排成最小的数](#面试题45-把数组排成最小的数)
- [面试题49 丑数](#面试题49-丑数)
- [面试题50 第一个只出现一次的字符位置](#面试题50-第一个只出现一次的字符位置)
- [面试题51](#面试题51)
- [面试题52 两个链表的第一个公共结点](#面试题52-两个链表的第一个公共结点)
- [数字在排序数组中出现的次数](#数字在排序数组中出现的次数)
- [面试题55 二叉树的深度](#面试题55-二叉树的深度)
- [平衡二叉树](#平衡二叉树)
- [数组中只出现一次的数字](#数组中只出现一次的数字)
- [和为S的连续正数序列](#和为s的连续正数序列)
- [面试题57 和为S的两个数字](#面试题57-和为s的两个数字)
- [左旋转字符串](#左旋转字符串)
- [翻转单词顺序列](#翻转单词顺序列)
- [扑克牌顺子](#扑克牌顺子)
- [面试题62 孩子们的游戏(圆圈中最后剩下的数)](#面试题62-孩子们的游戏圆圈中最后剩下的数)
- [求1+2+3+...+n](#求123n)
- [面试题67 不用加减乘除做加法](#面试题67-不用加减乘除做加法)
- [面试题6 把字符串转换成整数](#面试题6-把字符串转换成整数)
- [面试题3 数组中重复的数字](#面试题3-数组中重复的数字)
- [面试题66 构建乘积数组](#面试题66-构建乘积数组)
- [面试题19 正则表达式匹配](#面试题19-正则表达式匹配)
- [面试题20 表示数值的字符串](#面试题20-表示数值的字符串)
- [字符流中第一个不重复的字符](#字符流中第一个不重复的字符)
- [面试题23 链表中环的入口结点](#面试题23-链表中环的入口结点)
- [删除链表中重复的结点](#删除链表中重复的结点)
- [面试题8 二叉树的下一个结点](#面试题8-二叉树的下一个结点)
- [面试题28 对称的二叉树](#面试题28-对称的二叉树)
- [按之字形顺序打印二叉树](#按之字形顺序打印二叉树)
- [把二叉树打印成多行](#把二叉树打印成多行)
- [面试题37 序列化二叉树](#面试题37-序列化二叉树)
- [面试题54 二叉搜索树的第k大结点](#面试题54-二叉搜索树的第k大结点)
- [数据流中的中位数](#数据流中的中位数)
- [滑动窗口的最大值](#滑动窗口的最大值)
- [面试题12 矩阵中的路径](#面试题12-矩阵中的路径)
- [面试题13 机器人的运动范围](#面试题13-机器人的运动范围)
- [面试题34 二叉树中和为某一值的路径](#面试题34-二叉树中和为某一值的路径)

<!-- /TOC -->

### 面试题4 二维数组中的查找
你的思路：遍历  
书的时间复杂度变化：m*n变成m+n  
书：首先选择数组中右上角的数字。 
如果该数字大于要查找的数字，则剔除这个数字所在的列； 
如果该数字小于要查找的数字，则剔除这个数字所在的行  
也就是说，如果要查找的数字不在数组的右上角，则每一次都在数组的查找范围中剔除一行或者一列。
### 面试题5 替换空格	 
你的：
str.replace(i,i+1,"%20");
这题给C++出的，注意结尾
### 面试题6 从尾到头打印链表	
面试小提示：
在面试中，如果我们打算修改输入的数据，则最好先问面试官是不是允许修改。
### 面试题7 重建二叉树	 
选取合适的参数和返回值  
public static BinaryTreeNode recursion(int startPreorder,int endPreorder,int startInorder,int endInorder)  
### 面试题9 用两个栈实现队列	 
没啥说的
### 面试题11 旋转数组的最小数字	  
你的思路：
遍历一次找到最小；  
优化：   
二分查找的变形找到最小（或者最大）

搬是一样的
测试用例：
1、功能测试（输入的数组是升序排序数组的一个旋转，数组中有重复数字或者没有重复数字）
2、边界值测试（输入的数组是一个顺序排序数组，只包含一个数字）
3、特殊输入测试（输入null）
### 面试题10 斐波那契数列	
普通解法：一个简单的递归  
缺点：重复太多  
第一次优化：递归改循环，从0开始   
### 跳台阶
### 变态跳台阶
### 矩形覆盖	
### 面试题15 二进制中1的个数
通过&与运算判断最后一位为不为1,然后对这个数进行右移(<<)
n & 1
<<
### 面试题16 数值的整数次方	
普通：n次循环
优化：递归。变为logN
### 面试题21 调整数组顺序使奇数位于偶数前面	
找偶指针从头开始，找奇指针从尾开始  
### 面试题22 链表中倒数第k个结点	
两个指针
### 面试题24 反转链表	
不要想成反转，不然容易错。  
取出一个插入到另一个链表中。
### 面试题25 合并两个排序的链表	
取出一个插入到另一个链表中
### 面试题26 树的子结构
第一步：在树A中找到和树B的根节点的值一样的节点R
第二步：判断树A中以R为节点的子树是不是包含和B一样的结构。
尽量把判断情况的布尔值负载方法体中。  
### 面试题27 二叉树的镜像	  
没啥
### 面试题29 顺时针打印矩阵	  
每次打印一圈
### 面试题30 包含min函数的栈	 
辅助栈
### 面试题31 栈的压入、弹出序列	 
### 面试题32 从上往下打印二叉树	 
没啥
### 面试题33 二叉搜索树的后序遍历序列	 
在后续遍历得到的序列中，最后一个数字是树的根结点的值。  
数组中前面的数字可以分为两部分：  
第一部分是左子树节点的值，他们都比根节点的值小；  
第二部分是右子树节点的值，他们都比根节点的值大。  
### 面试题35 复杂链表的复制	
由于上述方法的时间花费在再次定位节点的上面，使用hash表记录配对信息。  
我们还是分两步：  
第一步仍然是复制原始链表上的每个节点N创建N'，然后吧这些创建出来的节点用next链接起来。同时我们把配对信息放到一个hash表中；  
第二步：由于有了hash表，我们可以用O(1)的时间根据S找到S'  
### 面试题36 二叉搜索树与双向链表	
中序的visit相当于插入节点。
### 面试题38 字符串的排列   
暴力必备
### 面试题39 数组中出现次数超过一半的数字	 
解法二、利用数组特点找出 O(N) 的算法：

题目中要找的数字出现的次数超过数组长度的一半，也就是说它出现的次数比其他所有数字出现的次数的和还要多。

因此我们可以考虑在遍历数组的时候保存两个值：一个是数组中的一个数字，一个是次数。

当我们遍历到下一个数字的时候，

如果下一个数字和当前我们保存的数字相同，则次数加 1；

如果和当前我们保存的数字不同，则次数减 1；

当次数减到 0 的时候，我们将保存的数字改为当前遍历所处的位置，并将次数更改为 1。
### 面试题41 最小的K个数	
思路一:排序法,  对n个数排序,然后迭代前k个数即可,时间复杂度以 快排为准 是O(nlogn),代码略   
思路二:局部替换法   假设前k个数就是整个数组中最小的,找出最大的数和k+1比较,如果比k+1大就和K=1互换位置,然后再将k数组中的最大数找出,在进行比较,知道数组末尾.时间复杂度O(nk)  
思路三: 对思路二中找最大数的优化,用前K个数建立最大堆,每次用堆顶元素和n-k中各个元素比较,如果堆顶元素较大,则互换位置,然后调整堆,使之重新成为最大堆。时间复杂度O（n*logk）
### 面试题42 连续子数组的最大和	  
举例分析数组的规律：
解题思路：  
1. 首先，我们需要定义一个变量currentSum，用for循环来记录前i项的和，currentSum每次都会更改，如果currentSum的值小于0，我们再往后加只有减小最大和，所以我们需要将array[i+1]项的值重新赋值给currentSum。  
2. 我们需要定义一个最大值max，每次改变currentSum的值时，我们都需要将max和currentSum进行比较，如果currentSum大于max，我们则将currentSum的值赋值给max。  
应用动态规划法：  
找出以第i个数字结尾的子数组的最大和，  
将动态规划公式转化成循环就是上面的公式。  
### 面试题43 整数中1出现的次数（从1到n整数中1出现的次数）	
从数字规律着手提高时间效率：  
534 = （个位1出现次数）+（十位1出现次数）+（百位1出现次数）=（53*1+1）+（5*10+10）+（0*100+100）= 214  
530 = （53*1）+（5*10+10）+（0*100+100） = 213  
504 = （50*1+1）+（5*10）+（0*100+100） = 201  
514 = （51*1+1）+（5*10+4+1）+（0*100+100） = 207  
10 = (1*1)+(0*10+0+1) = 2  
记每一位的权值为base，位值为weight，该位之前的数是former
### 面试题45 把数组排成最小的数	
1、全排列（必备解法）
2、本题有两个难点：第一个难点是相处一种新的比较规则来排序一个数组；第二个难点是证明这个比较规则是有效的，并且证明根据这个比较规则是有效的。



### 面试题49 丑数		
https://blog.csdn.net/jsqfengbao/article/details/47375263
### 面试题50 第一个只出现一次的字符位置	 
为了解决这个问题，我们可以定义哈希表的键值是字符，而值value是该字符出现的次数。同时我们还需要从头开始扫描字符串两次。
第一次扫描字符串时，每扫描到一个字符，就在哈希表的对应项中把次数加1。  
而接下来第二次扫描时，每扫描到一个字符，就能从hash表中得到该字符出现的次数。
### 面试题51 
逆序对的总数=左边数组中的逆序对的数量+右边数组中逆序对的数量+左右结合成新的顺序数组时中出现的逆序对的数量；
这样，算法是基于归并排序，时间复杂度是O(nlogn)，比直观的O(n2)要快。
### 面试题52 两个链表的第一个公共结点	
我们先要分别遍历两个链表得到它们的长度，并求出两个长度之差。在长的链表上先遍历若干次之后，再同步遍历两个链表，知道找到相同的结点，或者一直到链表结束。此时，如果第一个链表的长度为m，第二个链表的长度为n，该方法的时间复杂度为O(m+n)。
### 数字在排序数组中出现的次数	 
### 面试题55 二叉树的深度
递归遍历
### 平衡二叉树	
### 数组中只出现一次的数字	
### 和为S的连续正数序列	
### 面试题57 和为S的两个数字 
### 左旋转字符串	
### 翻转单词顺序列
### 扑克牌顺子
### 面试题62 孩子们的游戏(圆圈中最后剩下的数)	
### 求1+2+3+...+n	
### 面试题67 不用加减乘除做加法	
### 面试题6 把字符串转换成整数	  
### 面试题3 数组中重复的数字	
### 面试题66 构建乘积数组	 
构建查表矩阵
### 面试题19 正则表达式匹配	
### 面试题20 表示数值的字符串	
### 字符流中第一个不重复的字符	
### 面试题23 链表中环的入口结点	
https://blog.csdn.net/snow_7/article/details/52181049
### 删除链表中重复的结点	
### 面试题8 二叉树的下一个结点	
还有一个指向父节点的指针
https://blog.csdn.net/sbq63683210/article/details/51839408
### 面试题28 对称的二叉树	  
https://blog.csdn.net/sniperken/article/details/53889313 
### 按之字形顺序打印二叉树	
### 把二叉树打印成多行
### 面试题37 序列化二叉树	
https://blog.csdn.net/sniperken/article/details/53893338
### 面试题54 二叉搜索树的第k大结点	
左根右 到k
### 数据流中的中位数	
### 滑动窗口的最大值	
### 面试题12 矩阵中的路径
### 面试题13 机器人的运动范围	
### 面试题34 二叉树中和为某一值的路径
如果前序（深度遍历）时暂停的话，此时的栈，刚好是一条路径。
