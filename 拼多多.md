<!-- GFM-TOC -->
* [1.具体说一下cms，画一下图](#1.具体说一下cms，画一下图)
* [二、数据类型](#二数据类型)
    * [STRING](#string)
    * [LIST](#list)
    * [SET](#set)
    * [HASH](#hash)
    * [ZSET](#zset)
* [三、数据结构](#三数据结构)
    * [字典](#字典)
    * [跳跃表](#跳跃表)
* [四、使用场景](#四使用场景)
    * [计数器](#计数器)
    * [缓存](#缓存)
    * [查找表](#查找表)
    * [消息队列](#消息队列)
    * [会话缓存](#会话缓存)
    * [分布式锁实现](#分布式锁实现)
    * [其它](#其它)
* [五、Redis 与 Memcached](#五redis-与-memcached)
    * [数据类型](#数据类型)
    * [数据持久化](#数据持久化)
    * [分布式](#分布式)
    * [内存管理机制](#内存管理机制)
* [六、键的过期时间](#六键的过期时间)
* [七、数据淘汰策略](#七数据淘汰策略)
* [八、持久化](#八持久化)
    * [RDB 持久化](#rdb-持久化)
    * [AOF 持久化](#aof-持久化)
* [九、事务](#九事务)
* [十、事件](#十事件)
    * [文件事件](#文件事件)
    * [时间事件](#时间事件)
    * [事件的调度与执行](#事件的调度与执行)
* [十一、复制](#十一复制)
    * [连接过程](#连接过程)
    * [主从链](#主从链)
* [十二、Sentinel](#十二sentinel)
* [十三、分片](#十三分片)
* [十四、一个简单的论坛系统分析](#十四一个简单的论坛系统分析)
    * [文章信息](#文章信息)
    * [点赞功能](#点赞功能)
    * [对文章进行排序](#对文章进行排序)
* [参考资料](#参考资料)
<!-- GFM-TOC -->



##### 1.具体说一下cms，画一下图



 |新生代	 |老年代 |	设计特点（相似设计特特点的肯定是可以搭配使用的） |
 ---|---|---
Serial |	Serial Old	 |单线程
ParNew |	CMS	 |并发，低停顿时间
Parallel Scavenge  |	Parallel Old |	注重吞吐量

CMS 收集器流程：
	初始标记：仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，需要停顿
	并发标记：进行GC Roots Tracing的过程，它在整个回收过程中耗时最长，不需要停顿
	重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。
	并发清除：不需要停顿。
在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要停顿。
缺点：
吞吐量低：
无法处理浮动垃圾
标记 - 清除算法导致的空间碎片
2.	redis？源码看过么？（肯定没有啊）
String
List
SET
HASH
ZET
数据结构：
拉链法保存哈希冲突
渐进式 rehash
跳跃表是有序集合的底层实现之一。
       跳跃表是基于多指针有序链表实现的，可以看成多个有序链表。

1、	项目模块图
2、	一个线程一个页面么？那一个进程一个页面呢
3、	快排的特殊情况
4、	类加载器

快速排序的几个关键词：
1、先从数列中取出一个数作为基准数
2、分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边
基准数
小于或等于，概念要封闭起来

手写代码题
1、	手写策略模式代码
2、	查找a,b返回他们共同的根
问题：返回的不是真正找到没有的情况
3、	通过层次遍历把二叉树连成表
问题：队列循环前初始化也要判断空不空，代码重复
4、	机考第三题想办法降低时间复杂度

栈针里有哪些东西
滑动窗口
 
